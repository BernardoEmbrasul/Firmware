/*
 * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
 * All rights reserved. 
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
 * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
 * OF SUCH DAMAGE.
 *
 * This file is part of the lwIP TCP/IP stack.
 * 
 * Author: Adam Dunkels <adam@sics.se>
 *
 */


#include "lwip/opt.h"


//#if LWIP_NETCONN

//#include "lwip/api.h"
//#include "lwip/sys.h"
#include "lwip/udp.h"
#include "lwip/tcp.h"
#include "lwip/pbuf.h"

#include "string.h"
#include "netif.h"
#include "stm32f4xx_hal.h"


// #define UDPECHO_THREAD_PRIO  ( tskIDLE_PRIORITY + 5 )




static struct netconn *conn;
static struct netbuf *buf;
static struct netbuf *tbuf; //para transmissao
static struct ip4_addr *addr;
static struct ip4_addr *raddr; //para transmissao
static unsigned short port;

#define EXT extern
//#include "..\Port\global.h"

extern uint16_t udp_callback(uint8_t soc, uint8_t *rip, uint16_t rport, uint8_t *buf, uint16_t len);



struct udp_pcb *upcb;
struct udp_pcb *upcb1;


void udp_echoserver_receive_callback1(void *arg, struct udp_pcb *upcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
	 u8_t *data;
	  u16_t len;
		err_t err;
  /* Connect to the remote client
     err=udp_connect(upcb, addr, port);
     if(err != ERR_OK)
     {
    	 err=-err;
     } */





    //podemos chamar o callback legado
    udp_callback(NULL, addr, port, p->payload,   p->len);

    extern uint16_t ContSilencioMODBUS;
    ContSilencioMODBUS=10000;
    extern void timer_admite_nested_interrupt_srv();
    timer_admite_nested_interrupt_srv();

		//Atende � pergunta MODBUS, se houver uma..
		extern uint8_t HabResponder;
		if (HabResponder==1)
		{
			extern void ResponderMODBUS(void);
			ResponderMODBUS();
			HabResponder=0;
		}






  /* Free the p buffer */
  pbuf_free(p);

}


/*-----------------------------------------------------------------------------------*/
/*
static void udpecho_thread(void *arg)
{
  err_t err, recv_err;
  char msg[] = "tatanka";
  u8_t *data;
  u8_t rip [4]; //remote ip

  u16_t len;
  

  LWIP_UNUSED_ARG(arg);
  while (1){
  conn = netconn_new(NETCONN_UDP);
  if (conn!= NULL)
  {
    err = netconn_bind(conn, IP_ADDR_ANY, PORTA_);
    if (err == ERR_OK)
    {
      while (1) 
      {
        recv_err = netconn_recv(conn, &buf);
      
        if (recv_err == ERR_OK) 
        {
          addr = netbuf_fromaddr(buf);

          rip[0]=ip4_addr1(addr);
          rip[1]=ip4_addr2(addr);
          rip[2]=ip4_addr3(addr);
          rip[3]=ip4_addr4(addr);



          port = netbuf_fromport(buf);
          netconn_connect(conn, addr, port);
          buf->addr.addr = 0;
          netbuf_data(buf, &data, &len);//a informação tem tamanho len e esta em data[0],data[1],etc...

          //podemos chamar o callback legado
          udp_callback(NULL, rip, port, data,   len);

          extern uint16_t ContSilencioMODBUS;
          ContSilencioMODBUS=10000;
          extern void timer_admite_nested_interrupt_srv();
          timer_admite_nested_interrupt_srv();

			//Atende � pergunta MODBUS, se houver uma..
			extern uint8_t HabResponder;
			if (HabResponder==1)
			{
				extern void ResponderMODBUS(void);
				ResponderMODBUS();
				HabResponder=0;
			}

          netbuf_delete(buf);
        }
        else
        {
        	  printf("erro ao receber");

        }

      }
    }
    else
    {
      netconn_delete(conn);
      printf("can not bind netconn");
    }
  }
  else
  {
    printf("can create new UDP netconn");
  }
  }
}
*/
void udp_send1(uint8_t *Rem_IP, uint16_t NroPortaRemota, uint8_t *sendbuf, uint16_t len)
{
	/*
	tbuf=netbuf_new ( );
	IP4_ADDR(raddr, Rem_IP[0], Rem_IP[1], Rem_IP[2], Rem_IP[3]);
    //netconn_connect(conn, raddr, NroPortaRemota);
    tbuf->addr.addr = htonl(Rem_IP[3] |Rem_IP[2] << 8 | Rem_IP[1] << 16 | Rem_IP[0] << 24);
	netbuf_ref(tbuf, sendbuf, len);
    //netconn_send(conn,tbuf);
    netconn_sendto(conn, tbuf, addr, port);

	netbuf_delete(tbuf);

*/
	err_t err;
	typedef ip4_addr_t ip_addr_t;



	ip_addr_t  Ripaddr;
	struct pbuf *p;
	IP4_ADDR (&Ripaddr, Rem_IP [0], Rem_IP [1], Rem_IP [2], Rem_IP [3]);

	p=pbuf_alloc(PBUF_TRANSPORT, len, PBUF_POOL);

    //pbuf_take(p, sendbuf, len) ;
	 memcpy(p->payload, sendbuf, len); // payload copied


    //err= udp_connect(upcb,  &Ripaddr, NroPortaRemota);
	//err=-err;
     err= udp_connect(upcb1,  &Ripaddr, NroPortaRemota);
     if(err != ERR_OK)
     {
    	 err=-err;
     }


    //err=udp_send (upcb, p);
	err=udp_sendto (upcb1, p, &Ripaddr, NroPortaRemota); // the message back to the original host
    if(err != ERR_OK)
    {
   	 err=-err;
    }

	pbuf_free(p);
	  /* free the UDP connection, so we can accept new clients */
    udp_disconnect(upcb1);

}


/*-----------------------------------------------------------------------------------*/
void udp_config(void)
{
// sys_thread_new("udpecho_thread", udpecho_thread, NULL, DEFAULT_THREAD_STACKSIZE,UDPECHO_THREAD_PRIO );
  //udpecho_thread(NULL);
}







void udp_echoserver_init(uint16_t PORTA_)
{
 
   err_t err;
	 if (upcb1 !=NULL)
		 {
		   udp_remove(upcb1);
 
		 }
	 if (upcb  !=NULL)
		 {
		   udp_remove(upcb );
 
		 }

   /* Create a new UDP control block  */
   upcb = udp_new();
   upcb1 = udp_new();

   if (upcb)
   {
     /* Bind the upcb to the UDP_PORT port */
     /* Using IP_ADDR_ANY allow the upcb to be used by any local interface */
      err = udp_bind(upcb, IP_ADDR_ANY, PORTA_);

      if(err == ERR_OK)
      {
        /* Set a receive callback for the upcb */
        udp_recv(upcb, udp_echoserver_receive_callback1, NULL);
      }
      else
      {
        udp_remove(upcb);
        printf("can not bind pcb");
      }
   }
   else
   {
     printf("can not create pcb");
   }
}








//#endif /* LWIP_NETCONN */
